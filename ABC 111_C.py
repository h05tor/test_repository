"""
数列a1,a2,...,anが以下の条件を満たすとき、 /\/\/\/ と呼ぶことにします。

各i=1,2,...,n−2について、
・ai=ai+2
・数列に現れる数はちょうど2種類
偶数長の数列 v1,v2,...,vnが与えられます。 
要素をいくつか書き換えることでこの数列を /\/\/\/ にしたいです。 書き換える要素の数は最小でいくつになるか求めてください。

#奇数番目と偶数番目に分けて考える
奇数番目の組で一番多い値と偶数番目の組で一番多い値が異なる場合は
各組の要素数（n/2）から一番多い要素数を引いたものの合算

奇数番目の組で一番多い値と偶数番目の組で一番多い値が同じ場合は
奇数番目の組で一番多い値＆偶数番目の組で2番目に多い値、奇数番目の組で2番目に多い値＆偶数番目の組で1番多い値の2通り考え、小さい方

"""

n=int(input())
a=list(map(int,input().split()))
l1=[0]*100001
l2=[0]*100001
if a.count(a[0])==n:
    print(n//2)
    exit()

for i in range(0,n,2):
    l1[a[i]]+=1
for i in range(1,n,2):
    l2[a[i]]+=1

x,y=max(l1),max(l2)
#print(x,y)
i_x,i_y=l1.index(x),l2.index(y)
#print(i_x,i_y)

L1=sorted(l1,reverse=True)
L2=sorted(l2,reverse=True)

if i_x == i_y:
    #奇数番目を2番目に多い数でそろえる場合or偶数番目を2番目に多い数でそろえる場合で小さい方
    ans=min(((n//2-L1[1])+(n//2-L2[0])),((n//2-L1[0])+(n//2-L2[1])))
else:
    ans=((n//2-L1[0])+(n//2-L2[0]))
print(ans)
