"""
あるところに、洞窟があります。

洞窟には N個の部屋と M本の通路があり、部屋には 1からNの、通路には1からMの番号がついています。
通路iは部屋Aiと部屋Biを双方向につないでいます。
どの 2部屋間も、通路をいくつか通って行き来できます。部屋1は洞窟の入り口がある特別な部屋です。

洞窟の中は薄暗いので、部屋 1以外の各部屋に 
1つずつ道しるべを設けることにしました。各部屋の道しるべは、その部屋と通路で直接つながっている部屋の 
1つを指すように置きます。
洞窟の中は危険なので、部屋 1以外のどの部屋についても以下の条件を満たすことが目標です。

その部屋から出発し、「いまいる部屋にある道しるべを見て、それが指す部屋に移動する」ことを繰り返すと、部屋 
1に最小の移動回数でたどり着く。
目標を達成できる道しるべの配置が存在するか判定し、存在するならばそのような配置を 1つ出力してください。

制約
入力はすべて整数
2≤N≤10^5
1≤M≤2×10^5
1≤Ai,Bi≤N (1≤i≤M)
Ai≠Bi(1≤i≤M)
どの 2部屋間も、通路をいくつか通って行き来できる

入力は以下の形式で標準入力から与えられる。

N M
A1 B1
:
AM BM

出力
目標を達成できる道しるべの配置が存在しなければ No を出力せよ。
存在する場合、N行出力せよ。
1行目には Yes を、i(2≤i≤N)行目には部屋 iの道しるべが指す部屋の番号を出力せよ。


"""
#深さd+1の部屋は深さdの部屋と少なくとも1つ繋がっている
#深さd+1の部屋の道標が深さdの部屋を指すようにすればよい
from collections import deque
N, M = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(M)]
#print(AB)
links = [[] for _ in range(N + 1)]#links[i]は各部屋と道がつながっている部屋の集合。ここでは部屋0はないのでlinks[0]は空となる
#print(links)
for a, b in AB:
    links[a].append(b)#部屋aは部屋bと通じているため、links[a]にbを追加する
    links[b].append(a)#部屋bは部屋aと通じているため、links[b]にaを追加する
#print(links)
result = [-1] * (N + 1)#部屋0~Nにある道標の値。初期値は全部-1
q = deque([1])#最初は1にいるので1をデックにいれる
while q:
    i = q.popleft()#qの左端を取り除き、iに移す
    for j in links[i]:#linksに入っているものから参照していく
        if result[j] == -1:#部屋jの道標が-1の場合。つまり未探索の場合。
            result[j] = i#部屋jは部屋iと通じているという道標を置く
            q.append(j)#部屋jをdequeに入れる。
print('Yes')
print('\n'.join(str(i) for i in result[2:]))#部屋2以降を出力